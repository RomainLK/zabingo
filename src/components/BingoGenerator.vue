<template>
  <div class="container text-center">
    <div class="mb-3">
      <button type="button" class="btn btn-danger mr-2" @click="generate(null)">
        Generate
      </button>
      <button type="button" class="btn btn-primary mr-2" @click="download">
        Download
      </button>
      <button type="button" class="btn btn-warning mr-2" @click="reset">
        Reset
      </button>
    </div>

    <canvas class="d-inline" ref="bingoCanvas" v-on:click="mouseClick"></canvas>

    <div class="mb-5">
      <button type="button" class="btn btn-danger mr-2" @click="generate(null)">
        Generate
      </button>
      <button type="button" class="btn btn-primary mr-2" @click="download">
        Download
      </button>
      <button type="button" class="btn btn-warning mr-2" @click="reset">
        Reset
      </button>
    </div>
  </div>
</template>
<script>
import axios from "axios";
import { ReImg } from "@/libs/ReImg";

export default {
  async mounted() {
    const configName = this.searchParams.get("c");
    const { data } = await axios.get(`bingos/${configName}.json`);
    this.bingoConfig = data;
    // window.addEventListener("beforeunload", this.preventNav);
    // this.$once("hook:beforeDestroy", () => {
    //   window.removeEventListener("beforeunload", this.preventNav);
    // });
    let restore;
    if (this.searchParams.get("lines")) {
      restore = this.decodeList(this.searchParams.get("lines")).map(
        (i) => this.bingoLines[i]
      );
    }
    this.generate(restore);
  },
  data() {
    return {
      bingoConfig: {},
      isPlaying: false,
      bingoed: false,
      lines: [],
      table: [
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
      ],
    };
  },
  computed: {
    searchParams() {
      return new URLSearchParams(window.location.search);
    },
    bingoLines() {
      if (this.bingoConfig?.lines) {
        return this.bingoConfig.lines.map((text, index) => ({ text, index }));
      } else {
        return [];
      }
    },
  },
  methods: {
    reset() {
      this.isPlaying = false;
      this.bingoed = false;
      for (let y = 0; y < 5; y++) {
        for (let x = 0; x < 5; x++) {
          this.table[y][x] = 0;
        }
      }
      this.table[2][2] = 1;
      this.generate(this.lines);
    },
    checkBingo() {
      let forwardSum = 0; // \ diagonal
      let backwardSum = 0; // / diagonal
      const colSums = [0, 0, 0, 0, 0];
      for (let y = 0; y < 5; y++) {
        let rowSum = 0;
        forwardSum += this.table[y][y];
        backwardSum += this.table[4 - y][y];
        for (let x = 0; x < 5; x++) {
          rowSum += this.table[y][x];
          colSums[x] += this.table[y][x];
          if (colSums[x] === 5) {
            return true;
          }
        }
        if (rowSum === 5) {
          return true;
        }
      }
      if (forwardSum === 5 || backwardSum === 5) {
        return true;
      }
      return false;
    },
    mouseClick(event) {
      if (event.offsetX && event.offsetY) {
        const x = event.offsetX - 44;
        const y = event.offsetY - 476;
        if (x > 0 && y > 0 && x < 909 && y < 1350) {
          this.isPlaying = true;
          const tableX = Math.ceil(x / 164) - 1;
          const tableY = Math.ceil(y / 164) - 1;
          this.table[tableY][tableX] = 1;
          {
            //draw
            const context = this.$refs.bingoCanvas.getContext("2d");

            context.font = "16pt Arial";
            const cellX = tableX * 164 + 44;
            const cellY = tableY * 164 + 475;
            const width = 161;
            context.beginPath();
            context.lineWidth = "2";
            context.strokeStyle = "red";
            context.rect(cellX, cellY, width, width);
            context.stroke();
          }
          if (!this.bingoed && this.checkBingo()) {
            this.bingoed = true;
            alert("Bingo!");
          }
        }
      }
    },
    generate(generatedLines) {
      if (this.isPlaying) {
        if (!window.confirm("Abandon the game?")) {
          this.reset();
          return;
        }
      }

      const context = this.$refs.bingoCanvas.getContext("2d");
      context.canvas.width = 909;
      context.canvas.height = 1350;
      context.font = "16pt Arial";
      context.fillStyle = "0,0,0";

      const bg = new Image();
      bg.onload = () => {
        context.drawImage(bg, 0, 0);

        if (generatedLines) {
          this.lines = generatedLines;
        } else {
          this.lines = this.getRandomLines(this.bingoLines, 24);
          this.searchParams.set(
            "lines",
            this.encodeList(this.lines.map((l) => l.index))
          );
          history.pushState({}, "", "?" + this.searchParams.toString());
        }
        const linesCopy = this.lines.slice();
        const xOrigin = 45;
        const yOrigin = 480;
        const squareSide = 165;

        for (let line = 0; line < 5; line++) {
          for (let col = 0; col < 5; col++) {
            let text;
            if (col === 2 && line === 2) {
              const random = this.randomIndex(this.bingoConfig.freeTile.length);
              text = this.bingoConfig.freeTile[random];
            } else {
              text = linesCopy.pop().text;
            }
            this.wrapText(
              context,
              text,
              xOrigin + squareSide * col + squareSide / 2, // around horizontal center
              yOrigin + squareSide * line + squareSide / 2, //around vertical center
              squareSide,
              25
            );
          }
        }
      };
      bg.src = this.bingoConfig.img
        ? `/bingos/${this.bingoConfig.img}`
        : "/bingos/nvidia2020.jpg";
    },
    getRandomLines(array, size) {
      if (array.length < size) {
        throw new Error(
          `Array doesn't have enough elements (${array.length}) for requested size (${size})`
        );
      }
      const lines = array.slice();
      const result = [];
      for (let i = 0; i < size; i++) {
        const rand = this.randomIndex(lines.length);
        result.push(lines.splice(rand, 1)[0]);
      }
      return result;
    },

    randomIndex(length) {
      return Math.trunc(Math.random() * length);
    },

    encodeList(array) {
      return btoa(array.join(","));
    },
    decodeList(encoded) {
      return atob(encoded).split(",");
    },

    wrapText(context, text, x, y, maxWidth, lineHeight) {
      const words = text.split(" ");
      const final = [];
      let line = "";
      let metrics;
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + " ";
        metrics = context.measureText(testLine);

        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          final.push(line);

          line = words[n] + " ";
        } else {
          line = testLine;
        }
      }
      final.push(line);
      const finalHeight = final.length * lineHeight;

      let yStart = y - finalHeight / 2;
      for (const text of final) {
        const xStart = x - context.measureText(text).width / 2;

        context.fillText(text, xStart, yStart);
        yStart += lineHeight;
      }
    },
    download() {
      ReImg.fromCanvas(this.$refs.bingoCanvas).downloadPng("bingo.png");
    },
  },
};
</script>
